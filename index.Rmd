---
title: Web Scraping TecGEO
output: 
  flexdashboard::flex_dashboard:
    theme: 
      version: 4
      font_scale: 1
      bootswatch: journal
      primary: "#2C3E50"
      secondary: "#EB6864"
    favicon: "img/logo.png"
    navbar:
      - { icon: "fa-link", href: "https://tecnologiageo.com.br/", align: right}
      - { icon: "fa-instagram", href: "https://www.instagram.com/tecgeobr/", align: right}
      - { icon: "fa-code", href: "https://tecnologiageo.com.br/", align: right}
    options: (shiny.maxRequestSize = 700*1024^2)
runtime: shiny
---

```{css}
.shiny-output-area {
  margin: 0;
}

.full-width-image {
    width: 100vw; /* Define a largura igual à largura da janela do navegador */
    height: auto; /* Mantém a proporção original da imagem */
}
```

```{r setup, include=FALSE}
options(shiny.autoreload = TRUE)
options(gargle_oob_default = TRUE)
library(flexdashboard)
library(dplyr)
library(fontawesome)
library(leaflet.extras)
library(reactable)
library(mapview)
library(stringr)
library(leaflet)
library(visdat)
library(shinyWidgets)
library(explore)
library(plotly)
library(vroom)
library(xml2)
library(rvest)
library(cepR)
library(abjutils)
library(wordcloud)

token <- "33efdb7230265c63c301ced1bc16370b"
cep <- function(
    endereco = "joao-pessoa,rua-francisco-cavalcan, joao pessoa, paraiba, brasil"){
  
  padronizando_string <- function(x){
    stringr::str_split(string = abjutils::rm_accent(tolower(x)),
                       pattern = "\\s+")[[1L]] |> paste0(collapse = "-")
  }

  url <- glue::glue(
    "http://cep.la/{padronizando_string(x = endereco)}"
  ) |> httr::GET()
  
  url <- xml2::read_html(url)

  rvest::html_table(url)[[1L]][1,][[1L]] |> 
    stringr::str_replace("-", "") |> 
    cepR::busca_cep(token = token)
}

mapa <- function(df = NULL, imovel = NULL){

  if(is.null(df)){
    m <- data.frame(nome = "TecGeo", latitude = -7.1214628, longitude = -34.8655664) |> 
      sf::st_as_sf(coords=c("longitude", "latitude"), crs = 4326) |> 
      mapview::mapview()
    
    m <- leafem::addLogo(m, "https://tecnologiageo.com.br/static/images/logo_tecgeo2.png",
                    position = "bottomleft",
                    offset.x = 50,
                    offset.y = 250,
                    width = 180,
                    height = 100)
    return(m)
  }
  
  dados <- 
    df |> 
    sf::st_as_sf(coords=c("longitude", "latitude"), crs = 4326)
  
  if(!is.null(imovel)){
    dados <- 
      dados |> 
      dplyr::filter(tipo == imovel) |> 
      dplyr::select(-url, -z_lat, -z_lon)
    
    mapa <- dados |> 
      mapview::mapview()
  } else {
    mapa <- 
      dados |> 
      dplyr::filter(tipo == imovel) |> 
      mapview::mapview(legend = F, alpha = 0)
  }
  
  leafem::addLogo(mapa, "https://tecnologiageo.com.br/static/images/logo_tecgeo2.png",
                       position = "bottomleft",
                       offset.x = 50,
                       offset.y = 250,
                       width = 180,
                       height = 100)
}
```

# Sobre {data-icon="fa-home"}

```{r, fig.height=10, fig.align='center'}
img(src = "img/principal.png",  class = "full-width-image")
```

## Row {data-width="full"}

```{r fig.width=1}
knitr::include_graphics("img/logo.png")
```

Essa aplicação está sendo desenvolvida com a linguagem de programação [**R**](https://www.r-project.org/) e tem como objetivo evoluir para uma aplicação completa com recursos de visualização, descrição, modelagem e emissão de relatório automatizado de um imóvel, com base em algumas de suas características, levando em conta dados reais obtidos via [**web scraping**](https://en.wikipedia.org/wiki/Web_scraping) que são utilizados para o treinameto de um modelo de [**machine learning**](https://en.wikipedia.org/wiki/Machine_learning).

O modelo, que encontra-se em constante aprendizado, tem como objetivo estimar o valor do metro quadrado - $m^2$ com base em diversas caracrística do imóvel anunciado, sendo a sua geolocalização a principal característica. Entre outras características consideradas, pode-se citar a área, tipo do imóvel (apartamentos, casas, terrenos e flats), número de quartos, numero de banheiros, número de vagas de garagem, sendo essas variáveis numéricas. Também são consideras diversas outras dicotômicas (variáveis booleanas), que informa ao modelo a existência ou não de uma determinada característica no imóvel, como por exemplo, a existência ou não de elevador, piscina, salão de festa, academia, área de serviço, espaço gourmet, salão de festa, portaria, sauna, quadra poliesportiva, entre outras.

**Algumas observação**:

1 - Essa aplicação está em constante evolução;

2 - Alguns recursos disponíveis serão de maior interesse para quem está fazendo a modelagem e eventualmente poderão não fazer parte da aplicação final;

3 - Essa aplicação tem como objetivo utilizar a maior quantidade de recursos open source possíveis, visando confiabilidade e barateamento.

# Construir mapa pelo CSV {data-navmenu="Ferramentas" data-icon="fa-database"}

## Column {.sidebar}

```{r}
pickerInput(
    inputId = "tipoimovel",
    label = "Tipo de Imóvel",
    choices = c("casas", "apartamentos", "flat", "terrenos"),
    selected = c("casas", "apartamentos", "flat", "terrenos"),
    multiple = TRUE
  )

```

## Row {data-width=10000}

### `r fa("file-csv", fill = "darkblue")` Após o carregamento do CSV, aguarde até a renderização do mapa

```{r   eval=require('leaflet'), echo = FALSE}
library(spsComps)
options(shiny.maxRequestSize=700*1024^2)

dataset <- reactiveVal(NA)  # ReactiveVal para armazenar o conjunto de dados

renomeando_tipos <- function(x)
    stringr::str_split(x, "_")[[1L]][1L]

observeEvent(input$arquivo, {
  data <- vroom::vroom(input$arquivo$datapath, show_col_types = FALSE)
  tipos <- purrr::map_chr(.x = data$tipo, .f = renomeando_tipos)
  data$tipo <- tipos
  dataset(data)  # Atualizar o reactiveVal com o novo conjunto de dados
})

fileInput(
  "arquivo",
  "",
  buttonLabel = "Procure o CSV",
  placeholder = "Nenhum arquivo selecionado",
  accept = ".csv",
  width = '100%'
)

renderLeaflet({
  tryCatch(
    {
      req(dataset())
      mapa(df = dataset(), imovel = input$tipoimovel)
      
    }, error = function(e){
       mapa(df = NULL)
    }
  )})
```

## Column {.tabset .tabset-fade data-width=10000}
----------------------------------------------

### `r fa("table", fill = "darkblue")`

```{r}
  renderReactable({
  req(dataset())
  dados <- dataset() |> 
    dplyr::select(bairro, valor, area) |> 
    group_by(bairro) |> 
    summarise(valor_mediano = round(median(valor), 2L), valor_mediano_m2 = round(median(valor) / median(area), 2L), total = n())
  
  tab <- reactable(
    dados,
    filterable = TRUE,
    defaultPageSize = 15L,
    columns = list(
        valor_mediano_m2 = colDef(
          style = function(value) {
            color <- ifelse(log(value) > median(log(dados$valor_mediano_m2)), "#f1625c", "#5cf1b4")
            list(background = color)
          }
        )
      )
  )
  tab
})
```

### `r fa("binoculars", fill = "darkblue")`

```{r}
renderPlot({
  req(dataset())
  
  if(is.null(input$tipoimovel)){
    plot.new()
  }else {
    dados <- dataset() |> dplyr::filter(tipo == input$tipoimovel)
    visdat::vis_dat(dados)
  }})
```

### `r fa("chart-area", fill = "darkblue")`

```{r}
renderPlotly(
  {
    req(dataset())
    dados <- 
      dataset() |> 
      dplyr::mutate(valor_m2 = valor/area)
    explore::explore_density(dados, valor_m2 , target = tipo) |>
      plotly::ggplotly()
  }
)
```

### `r fa("file-word", fill = "darkblue")`

```{r}
renderPlot({
  req(dataset())
  
  freq <- 
  dataset() |> 
  group_by(bairro) |> 
  summarise(n = n())
  par(bg="black") 
  wordcloud(freq$bairro , freq$n , col=terrain.colors(length(freq$bairro) , alpha=0.9) , rot.per=0.3)
  
})
```

## Row

# Buscar coordenadas e CEP pelo endereço {data-navmenu="Ferramentas" data-icon="fa-magnifying-glass"}

```{r}
textInput(inputId = "endereco", label = "Informe o Endereço", value = "Av. Juarez Távora, 522 - Torre, Empresarial Maximum, Sala 608. João Pessoa, PB - Brasil, CEP - 58040-020", width = NULL,
  placeholder = NULL)

tabela <- reactiveVal(NA)  # ReactiveVal para armazenar o conjunto de dados

observeEvent(input$endereco, {
  m <- cep(input$endereco)
  tabela(m)# Atualizar o reactiveVal com o novo conjunto de dados
})

### Teste
renderTable({
  tryCatch(
    {
      tabela <- tabela()
      tabela$latitude <- formatC(tabela$latitude, format = "f", digits = 15L)
      tabela$longitude <- formatC(tabela$longitude, format = "f", digits = 15L)
      tabela
    }, error = function(e){
      tabela <- cep("Av. Juarez Távora, 522 - Torre, Empresarial Maximum, Sala 608. João Pessoa, PB - Brasil, CEP - 58040-020")
      tabela$latitude <- formatC(tabela$latitude, format = "f", digits = 15L)
      tabela$longitude <- formatC(tabela$longitude, format = "f", digits = 15L)
      tabela
    }
  )
})
```

### Endereço no mapa

```{r}
renderLeaflet({
    tryCatch(
    {
      req(tabela())
      m <- tabela() |>  
      sf::st_as_sf(coords=c("longitude", "latitude"), crs = 4326) |> 
      mapview::mapview(legend = FALSE)
      m@map
    }, error = function(e){
      m <- data.frame(nome = "TecGeo", latitude = -7.1214628, longitude = -34.8655664) |> 
        sf::st_as_sf(coords=c("longitude", "latitude"), crs = 4326) |> 
        mapview::mapview(legend = FALSE)
      m@map
    })
})
```
