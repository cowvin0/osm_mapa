---
title: Web Scraping TecGEO
output: 
  flexdashboard::flex_dashboard:
    theme: 
      version: 4
      font_scale: 1
      bootswatch: journal
      primary: "#2C3E50"
      secondary: "#EB6864"
    favicon: "img/logo.png"
    navbar:
      - { icon: "fa-link", href: "https://tecnologiageo.com.br/", align: right}
      - { icon: "fa-instagram", href: "https://www.instagram.com/tecgeobr/", align: right}
      - { icon: "fa-code", href: "https://tecnologiageo.com.br/", align: right}
    options: (shiny.maxRequestSize = 700*1024^2)
runtime: shiny
---

```{r setup, include=FALSE}
options(shiny.autoreload = TRUE)
options(gargle_oob_default = TRUE)
library(flexdashboard)
library(dplyr)
library(fontawesome)
library(leaflet.extras)
library(reactable)
library(mapview)
library(stringr)
library(leaflet)
library(visdat)
library(shinyWidgets)

mapa <- function(df = NULL, imovel = NULL){
  # renomeando_tipos <- function(x)
  #   stringr::str_split(x, "_")[[1L]][1L]
  
  if(is.null(df)){
    m <- data.frame(nome = "TecGeo", latitude = -7.1214628, longitude = -34.8655664) |> 
      sf::st_as_sf(coords=c("longitude", "latitude"), crs = 4326) |> 
      mapview::mapview()
    
    
    m <- leafem::addLogo(m, "https://tecnologiageo.com.br/static/images/logo_tecgeo2.png",
                    position = "bottomleft",
                    offset.x = 50,
                    offset.y = 250,
                    width = 160,
                    height = 100)
    return(m)
  }
    
  #tipos <- purrr::map_chr(.x = df$tipo, .f = renomeando_tipos)
  
  dados <- 
    df |> 
    sf::st_as_sf(coords=c("longitude", "latitude"), crs = 4326) |> 
    dplyr::select(-z_lat, -z_lon, -url, -bairro_completo) 
  
  #dados$tipo <- tipos
  
  if(!is.null(imovel)){
    dados <- 
      dados |> 
      dplyr::filter(tipo == imovel)
    
    mapa <- dados |> 
      mapview::mapview()
  } else {
    mapa <- 
      dados |> 
      dplyr::filter(tipo == imovel) |> 
      mapview::mapview(legend = F, alpha = 0)
  }
  
  mapa <- leafem::addLogo(mapa, "https://tecnologiageo.com.br/static/images/logo_tecgeo2.png",
                       position = "bottomleft",
                       offset.x = 50,
                       offset.y = 250,
                       width = 160,
                       height = 100)
  return(mapa)
}

```

# Sobre {data-icon="fa-home"}


```{r  eval=require('leaflet'), echo = FALSE}
df_map <- reactive({leaflet() |>
  addMarkers(-34.8655664, -7.1214628) |>
  leaflet::addTiles() |>
  setView(
  -34.8655664, -7.1214628, zoom = 27
)})
renderLeaflet({df_map()})
```

Row {data-width=full}
-------------------------------------

###
```{r}
    modalDialog(
      title = NULL,
      "Visualize esse dashboard pela tela de um computador. Você poderá enfrentar dificuldades para",
      "visualizar e manipular alguns elementos, caso esteja utilizando um dispositivo móvel de tela pequena.",
      "Nesses dispositivos, visualizar na horizontal poderá ajudar na renderização dos conteúdos.",
      easyClose = FALSE,
      footer = modalButton("Entendi")
    )
```


Essa aplicação tem como objetivo facilitar a visualização dos dados raspados de imóveis anunciados em um detreminado município. Para tanto, ela irá funcionar com os arquivos no formato Comma Separated Values - CSV gerados pelo webscraping.
 
**Algumas observação**:

1 - Basta fazer o upload do arquivo CSV;

2 - Você deve aguardar a renderização completa do mapa;

3 - O mapa é produzido usando a biblioteca [**mapview**](https://r-spatial.github.io/mapview/), da linguagem R e essa aplicação é construída usando a biblioteca [**shiny**](https://shiny.posit.co/) da linguagem R.


# Construir mapa pelo CSV {data-navmenu="Ferramentas" data-icon="fa-database"}


Column {.sidebar}
-----------------------------------------------------------------------

```{r}
# selectInput(
#   inputId = 'tipoimovel',
#   label = 'Tipo de Imóvel',
#   choices = c("casas", "apartamentos", "flat", "terrenos"), 
#   selected = c("casas", "apartamentos", "flat", "terrenos")
# )

pickerInput(
    inputId = "tipoimovel",
    label = "Tipo de Imóvel",
    choices = c("casas", "apartamentos", "flat", "terrenos"),
    selected = c("casas", "apartamentos", "flat", "terrenos"),
    multiple = TRUE
  )

```

Row
-------------------------------------
### `r fa("file-csv", fill = "darkblue")` Após o carregamento do CSV, aguarde até a renderização do mapa


```{r   eval=require('leaflet'), echo = FALSE}
library(spsComps)
options(shiny.maxRequestSize=700*1024^2)

dataset <- reactiveVal(NA)  # ReactiveVal para armazenar o conjunto de dados

renomeando_tipos <- function(x)
    stringr::str_split(x, "_")[[1L]][1L]

observeEvent(input$arquivo, {
  data <- read.csv(input$arquivo$datapath)
  tipos <- purrr::map_chr(.x = data$tipo, .f = renomeando_tipos)
  data$tipo <- tipos
  dataset(data)  # Atualizar o reactiveVal com o novo conjunto de dados
})

fileInput(
  "arquivo",
  "",
  buttonLabel = "Procure o CSV",
  placeholder = "Nenhum arquivo selecionado",
  accept = ".csv",
  width = '100%'
)

renderLeaflet({
  
  tryCatch(
    {
      req(dataset())
      mapa(df = dataset(), imovel = input$tipoimovel)
      
    }, error = function(e){
       mapa(df = NULL)
    }
  )})
```
Column {.tabset .tabset-fade}
-------------------------------------
### `r fa("table", fill = "darkblue")` Tabela Resumo

```{r}
  renderReactable({
  req(dataset())
  dados <- dataset() |> 
    dplyr::select(bairro, valor, area) |> 
    group_by(bairro) |> 
    summarise(valor_mediano = round(median(valor), 2L), valor_mediano_m2 = round(median(valor) / median(area), 2L), total = n()) |> 
    filter(total > 10L)
  
  tab <- reactable(
    dados,
    filterable = TRUE,
    defaultPageSize = 15L,
    columns = list(
        valor_mediano_m2 = colDef(
          style = function(value) {
            color <- ifelse(log(value) > median(log(dados$valor_mediano_m2)), "#f1625c", "#5cf1b4")
            list(background = color)
          }
        )
      )
  )
  tab
})
```

### `r fa("chart-simple", fill = "darkblue")` Visão exploratória dos dados

```{r}
renderPlot({
  req(dataset())
  dados <- dataset() |> dplyr::filter(tipo == input$tipoimovel)
  visdat::vis_dat(dados)
})
```
