---
title: Web Scraping TecGEO
output: 
  flexdashboard::flex_dashboard:
    theme: 
      version: 4
      font_scale: 1
      bootswatch: journal
      primary: "#2C3E50"
      secondary: "#EB6864"
    favicon: "img/logo.png"
    navbar:
      - { icon: "fa-link", href: "https://tecnologiageo.com.br/", align: right}
      - { icon: "fa-instagram", href: "https://www.instagram.com/tecgeobr/", align: right}
      - { icon: "fa-code", href: "https://tecnologiageo.com.br/", align: right}
    options: (shiny.maxRequestSize = 700*1024^2)
runtime: shiny
---

```{r setup, include=FALSE}
options(shiny.autoreload = TRUE)
options(gargle_oob_default = TRUE)
library(flexdashboard)
library(dplyr)
library(fontawesome)
library(leaflet.extras)
library(reactable)
library(mapview)
library(stringr)
library(leaflet)
library(visdat)
library(shinyWidgets)
library(explore)
library(plotly)
library(vroom)
library(xml2)
library(rvest)
library(cepR)
library(abjutils)

token <- "33efdb7230265c63c301ced1bc16370b"
cep <- function(
    endereco = "joao-pessoa,rua-francisco-cavalcan, joao pessoa, paraiba, brasil"){
  
  padronizando_string <- function(x){
    stringr::str_split(string = abjutils::rm_accent(tolower(x)),
                       pattern = "\\s+")[[1L]] |> paste0(collapse = "-")
  }

  url <- glue::glue(
    "http://cep.la/{padronizando_string(x = endereco)}"
  ) |> httr::GET()
  
  url <- xml2::read_html(url)

  rvest::html_table(url)[[1L]][1,][[1L]] |> 
    stringr::str_replace("-", "") |> 
    cepR::busca_cep(token = token)
}

mapa <- function(df = NULL, imovel = NULL){
  # renomeando_tipos <- function(x)
  #   stringr::str_split(x, "_")[[1L]][1L]
  
  if(is.null(df)){
    m <- data.frame(nome = "TecGeo", latitude = -7.1214628, longitude = -34.8655664) |> 
      sf::st_as_sf(coords=c("longitude", "latitude"), crs = 4326) |> 
      mapview::mapview()
    
    
    m <- leafem::addLogo(m, "https://tecnologiageo.com.br/static/images/logo_tecgeo2.png",
                    position = "bottomleft",
                    offset.x = 50,
                    offset.y = 250,
                    width = 180,
                    height = 100)
    return(m)
  }
  
  dados <- 
    df |> 
    sf::st_as_sf(coords=c("longitude", "latitude"), crs = 4326) |> 
    dplyr::select(-z_lat, -z_lon, -url, -bairro_completo) 
  
  if(!is.null(imovel)){
    dados <- 
      dados |> 
      dplyr::filter(tipo == imovel)
    
    mapa <- dados |> 
      mapview::mapview()
  } else {
    mapa <- 
      dados |> 
      dplyr::filter(tipo == imovel) |> 
      mapview::mapview(legend = F, alpha = 0)
  }
  
  leafem::addLogo(mapa, "https://tecnologiageo.com.br/static/images/logo_tecgeo2.png",
                       position = "bottomleft",
                       offset.x = 50,
                       offset.y = 250,
                       width = 180,
                       height = 100)
}
```

# Sobre {data-icon="fa-home"}


```{r  eval=require('leaflet'), echo = FALSE}
df_map <- reactive({leaflet() |>
  addMarkers(-34.8655664, -7.1214628) |>
  leaflet::addTiles() |>
  setView(
  -34.8655664, -7.1214628, zoom = 27
)})
renderLeaflet({df_map()})
```

Row {data-width=full}
-------------------------------------

###
```{r}
    modalDialog(
      title = NULL,
      "Visualize esse dashboard pela tela de um computador. Você poderá enfrentar dificuldades para",
      "visualizar e manipular alguns elementos, caso esteja utilizando um dispositivo móvel de tela pequena.",
      "Nesses dispositivos, visualizar na horizontal poderá ajudar na renderização dos conteúdos.",
      easyClose = FALSE,
      footer = modalButton("Entendi")
    )
```


Essa aplicação tem como objetivo facilitar a visualização dos dados raspados de imóveis anunciados em um detreminado município. Para tanto, ela irá funcionar com os arquivos no formato Comma Separated Values - CSV gerados pelo webscraping.
 
**Algumas observação**:

1 - Basta fazer o upload do arquivo CSV;

2 - Você deve aguardar a renderização completa do mapa;

3 - O mapa é produzido usando a biblioteca [**mapview**](https://r-spatial.github.io/mapview/), da linguagem R e essa aplicação é construída usando a biblioteca [**shiny**](https://shiny.posit.co/) da linguagem R.


# Construir mapa pelo CSV {data-navmenu="Ferramentas" data-icon="fa-database"}

Column {.sidebar}
-----------------------------------------------------------------------

```{r}
# selectInput(
#   inputId = 'tipoimovel',
#   label = 'Tipo de Imóvel',
#   choices = c("casas", "apartamentos", "flat", "terrenos"), 
#   selected = c("casas", "apartamentos", "flat", "terrenos")
# )

pickerInput(
    inputId = "tipoimovel",
    label = "Tipo de Imóvel",
    choices = c("casas", "apartamentos", "flat", "terrenos"),
    selected = c("casas", "apartamentos", "flat", "terrenos"),
    multiple = TRUE
  )

```

Row
-------------------------------------
### `r fa("file-csv", fill = "darkblue")` Após o carregamento do CSV, aguarde até a renderização do mapa


```{r   eval=require('leaflet'), echo = FALSE}
library(spsComps)
options(shiny.maxRequestSize=700*1024^2)

dataset <- reactiveVal(NA)  # ReactiveVal para armazenar o conjunto de dados

renomeando_tipos <- function(x)
    stringr::str_split(x, "_")[[1L]][1L]

observeEvent(input$arquivo, {
  data <- vroom::vroom(input$arquivo$datapath, show_col_types = FALSE)
  tipos <- purrr::map_chr(.x = data$tipo, .f = renomeando_tipos)
  data$tipo <- tipos
  dataset(data)  # Atualizar o reactiveVal com o novo conjunto de dados
})

fileInput(
  "arquivo",
  "",
  buttonLabel = "Procure o CSV",
  placeholder = "Nenhum arquivo selecionado",
  accept = ".csv",
  width = '100%'
)

renderLeaflet({
  tryCatch(
    {
      req(dataset())
      mapa(df = dataset(), imovel = input$tipoimovel)
      
    }, error = function(e){
       mapa(df = NULL)
    }
  )})
```
Column {.tabset .tabset-fade}
-------------------------------------
### `r fa("table", fill = "darkblue")`

```{r}
  renderReactable({
  req(dataset())
  dados <- dataset() |> 
    dplyr::select(bairro, valor, area) |> 
    group_by(bairro) |> 
    summarise(valor_mediano = round(median(valor), 2L), valor_mediano_m2 = round(median(valor) / median(area), 2L), total = n())
  
  tab <- reactable(
    dados,
    filterable = TRUE,
    defaultPageSize = 15L,
    columns = list(
        valor_mediano_m2 = colDef(
          style = function(value) {
            color <- ifelse(log(value) > median(log(dados$valor_mediano_m2)), "#f1625c", "#5cf1b4")
            list(background = color)
          }
        )
      )
  )
  tab
})
```

### `r fa("binoculars", fill = "darkblue")`

```{r}
renderPlot({
  req(dataset())
  
  if(is.null(input$tipoimovel)){
    plot.new()
  }else {
    dados <- dataset() |> dplyr::filter(tipo == input$tipoimovel)
    visdat::vis_dat(dados)
  }})
```

### `r fa("chart-area", fill = "darkblue")`

```{r}
renderPlotly(
  {
    req(dataset())
    dados <- 
      dataset() |> 
      dplyr::mutate(valor_m2 = valor/area)
    explore::explore_density(dados, valor_m2 , target = tipo) |>
      plotly::ggplotly()
  }
)
```

Row
-------------------------------------

# Buscar coordenadas e CEP pelo endereço {data-navmenu="Ferramentas" data-icon="fa-magnifying-glass"}

```{r}
textInput(inputId = "endereco", label = "Informe o Endereço", value = "Av. Juarez Távora, 522 - Torre, Empresarial Maximum, Sala 608. João Pessoa, PB - Brasil, CEP - 58040-020", width = NULL,
  placeholder = NULL)

tabela <- reactiveVal(NA)  # ReactiveVal para armazenar o conjunto de dados

observeEvent(input$endereco, {
  m <- cep(input$endereco)
  tabela(m)# Atualizar o reactiveVal com o novo conjunto de dados
})

### Teste
renderTable({
  tryCatch(
    {
      tabela <- tabela()
      tabela$latitude <- formatC(tabela$latitude, format = "f", digits = 15L)
      tabela$longitude <- formatC(tabela$longitude, format = "f", digits = 15L)
      tabela
    }, error = function(e){
      tabela <- cep("Av. Juarez Távora, 522 - Torre, Empresarial Maximum, Sala 608. João Pessoa, PB - Brasil, CEP - 58040-020")
      tabela$latitude <- formatC(tabela$latitude, format = "f", digits = 15L)
      tabela$longitude <- formatC(tabela$longitude, format = "f", digits = 15L)
      tabela
    }
  )
})
```
### Endereço no mapaa 
```{r}
renderLeaflet({
    tryCatch(
    {
      req(tabela())
      m <- tabela() |>  
      sf::st_as_sf(coords=c("longitude", "latitude"), crs = 4326) |> 
      mapview::mapview(legend = FALSE)
      m@map
    }, error = function(e){
      m <- data.frame(nome = "TecGeo", latitude = -7.1214628, longitude = -34.8655664) |> 
        sf::st_as_sf(coords=c("longitude", "latitude"), crs = 4326) |> 
        mapview::mapview(legend = FALSE)
      m@map
    })
})
```